syntax = "proto3";

package pbft;

option go_package = "pbft/proto;pbftproto";

// ==== Messages ====

// The PrePrepare the primary broadcasts
message PrePrepareMsg {
  uint64 view      = 1;  // v
  uint64 seq       = 2;  // n
  bytes  digest    = 3;  // d = Hash(client request)
  uint64 primaryId = 4;  // id of primary
  bytes  signature = 5;  // sig_primary( v || n || d )
  ClientRequest request = 6; // original client request
}

// Ack that replicas send back
message PrePrepareAck {
  uint64 view     = 1;
  uint64 seq      = 2;
  bytes  digest   = 3;
  uint64 replicaId = 4;
  bytes  signature = 5; // sig_replica( v || n || d )
}

message PrepareMsg {
  uint64 view   = 1;      // v
  uint64 seq    = 2;      // n
  bytes  digest = 3;      // d
  uint64 primaryId = 4;
  bytes  signature = 5;   // sig_primary(v||n||d)
  repeated uint64 quorum_ids = 6;
}

message PrepareAck {
  uint64 view      = 1;
  uint64 seq       = 2;
  bytes  digest    = 3;
  uint64 replicaId = 4;
  bytes  signature = 5;   // sig_replica(v||n||d)
}

message CommitMsg {
  uint64 view       = 1;  // v
  uint64 seq        = 2;  // n
  bytes  digest     = 3;  // d
  uint64 primaryId  = 4;
  bytes  signature  = 5;  // sig_primary( v || n || d )
  repeated uint64 quorum_ids = 6;
}

message CommitAck {
  uint64 view       = 1;
  uint64 seq        = 2;
  bytes  digest     = 3;
  uint64 replicaId  = 4;
  bytes  signature  = 5;  // sig_replica( v || n || d )
}

message Checkpoint {
  uint64 seq = 1;        // last stable checkpoint sequence
  bytes  state_digest = 2; // for now: always empty; future: hash of state
}

// Summary of a log entry relevant for view-change.
message ViewChangeEntry {
  uint64 seq       = 1;
  uint64 view      = 2;
  bytes  digest    = 3;
  string status    = 4;        // "PrePrepare", "Prepare", "Commit", etc.
  repeated uint64 quorum_prepare = 5; // optional: replica IDs that prepared
}

// Sent by a replica i to the new primary for view v'.
message ViewChangeMsg {
  uint64 new_view   = 1;
  uint64 replica_id = 2;
  Checkpoint checkpoint = 3;
  repeated ViewChangeEntry entries = 4;
  bytes signature   = 5; // sig over (new_view, checkpoint.seq, entries digests)
}

// Simple ack from the would-be primary.
message ViewChangeAck {
  bool ok = 1;
  string message = 2;
}

message NewViewPrePrepare {
  uint64 view = 1;               // new view
  uint64 seq = 2;
  bytes  digest = 3;
  ClientRequest request = 4;     // may be empty if not available
}

message NewViewMsg {
  uint64 new_view    = 1;
  uint64 primary_id  = 2;
  repeated ViewChangeMsg view_changes = 3;    // proofs (for now, full VCs; can optimize later)
  repeated NewViewPrePrepare pre_prepares = 4;
  bytes  signature   = 5;       // primary’s sig over canonical encoding of the above
}

message ClientRequest {
  string from      = 1;
  string to        = 2;
  uint64 amount    = 3;
  string timestamp = 4;
  string client_addr = 5; 
}

message ClientReply {
  bool   success   = 1;
  string message   = 2;  // "ok", "Insufficient balance", etc.
  uint64 view      = 3;  // current view at responder
  uint64 seq       = 4;  // seq of the request
  uint64 balance   = 5;  // optional for read-only
  string from = 6;         // original client id ("A"... "J")
  string timestamp = 7;    // copied from request.timestamp (A1, A2, ...)
  uint64 replica_id = 8;
}

message ResetRequest {}
message ResetReply { bool ok = 1; }

// ==== RPC services ====

// Replicas expose this so the PRIMARY can call BroadcastPrePrepare().
service ReplicaService {
    rpc HandlePrePrepare(PrePrepareMsg) returns (AckReceipt);
    rpc HandlePrepare(PrepareMsg)       returns (AckReceipt); // <—
    rpc HandleCommit(CommitMsg)         returns (AckReceipt); 
}

// Primary exposes this so REPLICAS can send PrePrepareAck().
service PrimaryService {
    rpc SendPrePrepareAck(PrePrepareAck) returns (AckReceipt);
    rpc SendPrepareAck(PrepareAck)        returns (AckReceipt);
    rpc SendCommitAck(CommitAck)         returns (AckReceipt);
    rpc HandleViewChange(ViewChangeMsg) returns (ViewChangeAck);
    rpc HandleNewView(NewViewMsg) returns (AckReceipt);
    rpc HandleClientRequest(ClientRequest) returns (ClientReply);
    rpc ResetState(ResetRequest) returns (ResetReply);
}

service ClientService {
  rpc DeliverClientReply(ClientReply) returns (ResetRequest);
}

// Just a basic response wrapper.
message AckReceipt {
  bool ok = 1;
  string message = 2;
}
